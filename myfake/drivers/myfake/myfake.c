#include <linux/init.h> 
#include <linux/module.h> 
#include <linux/types.h> 
#include <linux/fs.h> 
#include <linux/proc_fs.h> 
#include <linux/device.h> 
#include <asm/uaccess.h> 

#include "myfake.h" 

//主设备号和从设备号 
static int myfake_major = 0; 
static int myfake_minor = 0; 

//设备类别和设备变量 
static struct class* myfake_class = NULL; 
static struct myfake_android_dev* myfake_dev = NULL; 

//传统的设备文件操作方法 
static int myfake_open(struct inode* inode, struct file* flip); 
static int myfake_release(struct inode* inode, struct file* flip); 
static ssize_t myfake_read(struct file* flip, char __user* buf, size_t count, loff_t* f_pos); 
static ssize_t myfake_write(struct file* flip, const char __user* buf, size_t count, loff_t* f_pos); 

//传统的设备文件操作方法
static struct file_operations myfake_fops = { 
	.owner = THIS_MODULE, 
	.open = myfake_open, 
	.release = myfake_release, 
	.read = myfake_read, 
	.write = myfake_write, 
};

//devfs文件系统的设备属性操作方法 
static ssize_t myfake_val_show(struct device* dev, struct device_attribute* attr, char* buf); 
static ssize_t myfake_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count); 

//devfs文件系统的设备属性 
static DEVICE_ATTR(val, S_IRUGO | S_IWUSR, myfake_val_show, myfake_val_store);

//传统设备文件的打开接口 
static int myfake_open(struct inode* inode, struct file* flip) 
{ 
    struct myfake_android_dev* dev; 
    //将结构体变量保存到私有区域 
    dev = container_of(inode->i_cdev, struct myfake_android_dev, dev);
    flip->private_data = dev; pr_info("myfake_open\n"); return 0; 
} 

//传统设备文件的释放接口 
static int myfake_release(struct inode* inode, struct file* filp) 
{ 
    pr_info("myfake_release\n"); 
    return 0; 
} 

//传统设备文件的读取接口 
static ssize_t myfake_read(struct file* filp, char __user* buf, size_t count, loff_t* f_pos) 
{ 
    ssize_t err = 0; 
    struct myfake_android_dev* dev = filp->private_data; 
    //锁住信号量，以保证同步访问 
    if(down_interruptible( &(dev->sem) )) 
    { 
        return -ERESTARTSYS;  
    } 
    if(count < sizeof(dev->val) ) 
    { 
        goto out; 
    } 
    // 将数据拷贝到用户提供的缓存区中 
    if(copy_to_user(buf, &(dev->val), sizeof(dev->val) )) 
    { 
    	err = -EFAULT; 
    	goto out; 
    } 
    err = sizeof(dev->val);

out:  
    //释放同步信号
    up(&(dev->sem));
    pr_info("myfake_read\n");

    return err;
}


//传统写
static ssize_t myfake_write(struct file* filp, const char __user* buf, size_t count, loff_t* f_pos)
{

	struct myfake_android_dev* dev = filp->private_data;
	ssize_t err = 0;

	//锁住信号量，以保证同步访问
	if(down_interruptible( &(dev->sem)))
	{

		return -ERESTARTSYS;
	}

	if (count != sizeof(dev->val))
	{
		goto out;
	}

	//get data from user cache
	if(copy_to_user( &(dev->val), buf, count))
	{

		err = -EFAULT;
		goto out;
	}

	err = sizeof(dev->val);

out:
    up(&(dev->sem));
    pr_info("myfake_write\n");
    return err;
}


//将myfake_android_dev.val数据拷贝到用户的缓冲区中，仅供内部使用
static ssize_t __myfake_get_val(struct myfake_android_dev* dev, char* buf)
{

	int val = 0;

	if(down_interruptible( &(dev->sem)))
	{

		return -ERESTARTSYS;
	}

	val = dev->val;

	up ( &(dev->sem));
	return snprintf(buf, PAGE_SIZE, "%d\n", val);

}

//将用户提供的数据写入到myfake_android_dev.val变量中，仅供内部使用 
static ssize_t __myfake_set_val(struct myfake_android_dev* dev, const char* buf, size_t count) 
{ 
    int val = 0; 
    //字符串转为数字 
    val = simple_strtol(buf, NULL, 10); 
    //同步访问 
    if(down_interruptible( &(dev->sem) )) 
    { 
    	return -ERESTARTSYS;
    } 
    dev->val = val; 
    up( &(dev->sem)); 
    return count; 
}


//devfs文件系统的读接口 
static ssize_t myfake_val_show(struct device* dev, struct device_attribute* attr, char* buf) 
{ 
    struct myfake_android_dev* hdev = (struct myfake_android_dev*)dev_get_drvdata(dev); 
    pr_info("myfake_val_show\n"); 
    return __myfake_get_val(hdev, buf); 
} 
    
//devfs文件系统的写接口 
static ssize_t myfake_val_store(struct device* dev, struct device_attribute* attr, const char* buf, size_t count) 
{ 
    struct myfake_android_dev* hdev = (struct myfake_android_dev*)dev_get_drvdata(dev); 
    pr_info("myfake_val_store\n"); 
    return __myfake_set_val(hdev, buf, count); 
} 
//proc文件系统的读接口 
static ssize_t myfake_proc_read(char* page, char** start, off_t off, int count, int* eof, void* data) 
{ 
	if(off > 0) 
    { 
    	*eof = 1; 
    	return 0; 
    } 
    pr_info("myfake_proc_read\n");

    return __myfake_get_val(myfake_dev, page); 
} 
//proc文件系统的写接口 
static ssize_t myfake_proc_write(struct file* filp, const char __user* buff, unsigned long len, void* data) 
{ 
    int err = 0; 
    char* page = NULL;
    if(len > PAGE_SIZE)
    { 
        printk(KERN_ALERT"The buff is too large:%lu.\n", len); 
        return -EFAULT; 
    } 
    page = (char*)__get_free_page(GFP_KERNEL); 
    if(!page)
    { 
        printk(KERN_ALERT"Failed to alloc page.\n"); 
        return -ENOMEM; 
    } 
    // copy the user buffer value to kernel buffer 
    if(copy_from_user(page, buff, len) )
    { 
        printk(KERN_ALERT"Failed to copy buff from user.\n"); 
        err = -EFAULT; 
        goto out; 
    } 
    err = __myfake_set_val(myfake_dev, page, len);

out: 
    free_page( (unsigned long)page); 
    pr_info("myfake_proc_write\n"); 
    return err; 
} 

//创建proc文件系统，仅供内部使用 
static void myfake_create_proc(void) 
{ 
    struct proc_dir_entry* entry; 
    entry = create_proc_entry(MYFAKE_DEVICE_PROC_NAME, 0, NULL); 
    if(entry) 
    { 
    //entry->owner = THIS_MODULE; 
    entry->read_proc = myfake_proc_read; 
    entry->write_proc = myfake_proc_write; 
    } 
} 

//删除proc文件系统，仅供内部使用 
static void myfake_remove_proc(void) 
{ 
	remove_proc_entry(MYFAKE_DEVICE_PROC_NAME, NULL);
} 

//初始化设备 
static int __myfake_setup_dev(struct myfake_android_dev* dev) 
{ 
	int err; 
	dev_t devno = MKDEV(myfake_major, myfake_minor); 
	memset(dev, 0, sizeof(struct myfake_android_dev) ); 
	cdev_init( &(dev->dev), &myfake_fops); 

	//dev->dev.owner = THIS_MODULE; 
	dev->dev.ops = &myfake_fops; 

	//注册字符设备 
	err = cdev_add( &(dev->dev), devno, 1); 
	if(err) 
	{ 
	    return err; 
	} 

	//初始化信号量 
	init_MUTEX(&(dev->sem)); dev->val = 0; return 0; 

} 

//模块初始化 
static int __init myfake_init(void) 
{ 
    int err = -1; 
    dev_t dev = 0; 
    struct device* temp = NULL; 
    printk(KERN_ALERT"Initializing myfake device.\n"); 

    //分配设备号码 
    err = alloc_chrdev_region( &dev, 0, 1, MYFAKE_DEVICE_NODE_NAME);
    if(err < 0) 
    { 
        printk(KERN_ALERT"Failed to alloc char dev region.\n"); 
        goto fail; 
    } 

    myfake_major = MAJOR(dev); 
    myfake_minor = MINOR(dev); 

    // 分配设备结构体的空间 
    myfake_dev = kmalloc( sizeof(struct myfake_android_dev), GFP_KERNEL); 
    if(!myfake_dev) 
    { 
    	err = -ENOMEM; 
    	printk(KERN_ALERT"Failed to alloc myfake_dev.\n"); 
    	goto unregister; 
    }

    //初始化设备 
    err = __myfake_setup_dev(myfake_dev); 
    if(err) 
    { 
        printk(KERN_ALERT"Failed to setup dev:%d.\n", err); 
        goto cleanup; 
    } 

    //创建传统设备文件系统的接口设备 
    // create device type directory myfake on /sys/class/ 
    myfake_class = class_create(THIS_MODULE, MYFAKE_DEVICE_CLASS_NAME);
    if(IS_ERR(myfake_class)) 
    { 
        err = PTR_ERR(myfake_class); 
        printk(KERN_ALERT"Failed to create myfake class.\n"); 
        goto destroy_cdev; 
    } 

    // create device file myfake on /dev/ and /sys/class/myfake 
    temp = device_create(myfake_class, NULL, dev, "%s", MYFAKE_DEVICE_FILE_NAME); 
    if(IS_ERR(temp)) 
    { 
        err = PTR_ERR(temp); 
        printk(KERN_ALERT"Failed to create myfake device.\n"); 
        goto destroy_class; 
    } 
    //创建devfs文件系统接口设备 
    // create property file val on /sys/class/myfake/myfake 
    err = device_create_file(temp, &dev_attr_val); 
    if(err < 0) 
    { 
        printk(KERN_ALERT"Failed to create attribute val.\n"); 
        goto destroy_device; 

    } 
    dev_set_drvdata(temp, myfake_dev); 

    //创建proc文件系统接口设备 
    // create /proc/myfake file 
    myfake_create_proc(); 
    printk(KERN_ALERT"Successed to initialize myfake device.\n"); 
    return 0; 

destroy_device: 
    device_destroy(myfake_class, dev); 
destroy_class: 
    class_destroy(myfake_class);


destroy_cdev: 
    cdev_del(&myfake_dev->dev); 

cleanup: 
    kfree(myfake_dev); 
unregister: 
    unregister_chrdev_region(MKDEV(myfake_major, myfake_minor), 1); 
fail: 
    return err; 
} 

//卸载模块 
static void __exit myfake_exit(void) 
{ 
    dev_t devno = MKDEV(myfake_major, myfake_minor); 
    printk(KERN_ALERT"Destroy myfake device.\n"); 

    //删除proc文件系统接口设备 
    myfake_remove_proc(); 
    //删除devfs文件系统接口设备 
    if(myfake_class) 
    { 
        device_destroy(myfake_class, MKDEV(myfake_major, myfake_minor) ); 
        class_destroy(myfake_class); 
    } 

    //传统设备文件系统的接口设备 
    if(myfake_dev) 
    { 
        cdev_del(&(myfake_dev->dev) ); 
        kfree(myfake_dev);
    } 

    // destroy device number 
    unregister_chrdev_region(devno, 1); 
} 

MODULE_LICENSE("GPL"); 
MODULE_DESCRIPTION("First Android Device"); 

module_init(myfake_init);
module_exit(myfake_exit);



