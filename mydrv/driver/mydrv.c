#include <linux/interrupt.h>
#include <linux/module.h>
#include <linux/dma-mapping.h>
#include <linux/clk.h>
#include <linux/platform_device.h>
#include <linux/cpufreq.h>
#include <linux/debugfs.h>
#include <linux/seq_file.h>
#include <linux/irq.h>
#include <linux/io.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include <mach/dma.h>
#include <linux/delay.h>
#include <asm/delay.h>
#include <linux/miscdevice.h>
#include <linux/ioctl.h>
#include <linux/kernel.h>

#include <linux/slab.h>
#include <linux/sched.h>
//#include <linux/smp_lock.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/mm.h>
#include <linux/err.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/backing-dev.h>
#include <linux/compat.h>
#include <linux/mount.h>

#include <asm/uaccess.h>

#include "x_typedef.h"
#include "drv_dual.h"
#include "backcar_msg.h"
#include "drv_av_d.h"
#include "pmx_hal.h"
#include "wch_if.h"
#include "ac83xx_memory.h"
#include "ac83xx_gpio_pinmux.h"
#include "ac83xx_pinmux_table.h"
#include "pinmux_reg.h"
#include <linux/gpio.h>

#include <linux/types.h>
#include <linux/fs.h>
#include <asm/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/platform_device.h>
#include <linux/sched.h>

#include "x_typedef.h"
#include "windev.h"
#include "oal.h"
#include "x_ver.h"

#include <linux/kthread.h>
#include <linux/semaphore.h>

#include <linux/interrupt.h>
#include <linux/module.h>
#include <linux/dma-mapping.h>
#include <linux/clk.h>
#include <linux/platform_device.h>
#include <linux/cpufreq.h>
#include <linux/debugfs.h>
#include <linux/seq_file.h>
#include <linux/irq.h>
#include <linux/io.h>
#include <linux/wait.h>
#include <linux/slab.h>
#include <mach/dma.h>
#include <linux/delay.h>
#include <asm/delay.h>
#include <linux/miscdevice.h>
#include <linux/ioctl.h>
#include <linux/kernel.h>

#include <linux/slab.h>
#include <linux/sched.h>
//#include <linux/smp_lock.h>
#include <linux/init.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/device.h>
#include <linux/mm.h>
#include <linux/err.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/backing-dev.h>
#include <linux/compat.h>
#include <linux/mount.h>
#include <linux/gpio.h>

#include <linux/types.h>
#include <linux/fs.h>
#include <asm/uaccess.h>
#include <linux/miscdevice.h>
#include <linux/platform_device.h>
#include <linux/sched.h>
#include <linux/kthread.h>
#include <linux/semaphore.h>

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/init.h>
#include <linux/delay.h>
#include <asm/uaccess.h>
#include <asm/irq.h>
#include <asm/io.h>
//#include <asm/arch/regs-gpio.h>
//#include <asm/hardware.h>
#include <linux/device.h>

typedef unsigned char U8;
typedef unsigned short U16;
typedef unsigned int U32;

typedef signed char S8;
typedef signed short S16;
typedef signed int S32;


static struct class *mydrv_class;
static struct class_device *mydrv_class_dev;

static long u4UsingGPIOPinNum;

void GPIO_Init(unsigned long u4GPIOPinNum)
{
    u4UsingGPIOPinNum = u4GPIOPinNum;

    GPIO_MultiFun_Set(u4GPIOPinNum,PINMUX_LEVEL_GPIO_END_FLAG);
    gpio_request(u4GPIOPinNum,"BackCar_Init_GPIO");
    gpio_direction_output(u4GPIOPinNum,1);
    printk("cuishang GPIO %d Init Success!\r\n",u4UsingGPIOPinNum);
}

int GPIO_Get_value()
{
    int u8Val = gpio_get_value(u4UsingGPIOPinNum);    
    return u8Val;
}

static int mydrv_open(struct inode *inode, struct file *file)
{
	printk("cuishang file open,GPIO_Init!\n");
	GPIO_Init(177);
	return 0;
}


static ssize_t mydrv_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
{
	printk("cuishang file write\n");
	return 0;
}

static int mydrv_ioctl( struct file *file, unsigned int cmd, unsigned long arg)
{
	unsigned long u8Temp;

	printk("cuishang file ioctl\n");

    printk("cuishang cmd = %d\n", cmd);
    switch(cmd)
    {
        case 1:
            if (copy_from_user(&u8Temp, (unsigned long *) arg, sizeof(unsigned long)))
            {
                return -EFAULT;
            }

            gpio_direction_output(177, 1);
            break;
        case 0:
            if (copy_from_user(&u8Temp, (unsigned long *) arg, sizeof(unsigned long)))
            {
                return -EFAULT;
            }
            gpio_direction_output(177, 0);
            break;
        default:
            printk("cuishang ioctl: unknown command\n");
    }

	return 0;
}

static int mydrv_release(struct inode *inode, struct file *file)
{
    printk("mydrv_release\n");

    return 0;
}

static const struct file_operations mydrv_fops = {
    .owner            = THIS_MODULE,
    .open = mydrv_open,
    .release = mydrv_release,
    .write = mydrv_write,
    .unlocked_ioctl   = mydrv_ioctl,
};

int mydrv_major = 0;
int mydrv_minor = 0;

int mydrv_init(void)
{
	mydrv_major = register_chrdev(0,"mydrv", &mydrv_fops);//注册
	
	mydrv_class = class_create(THIS_MODULE, "mydrv");
	if (IS_ERR(mydrv_class))
	{
		return PTR_ERR(mydrv_class);
	}

	mydrv_class_dev = device_create(mydrv_class, NULL, MKDEV(mydrv_major, 0), NULL, "mydrv");
	if (unlikely(IS_ERR(mydrv_class_dev)))
	{
		return PTR_ERR(mydrv_class_dev);
	}

	return 0;
}

void mydrv_exit(void) 
{
	unregister_chrdev(mydrv_major,"mydrv");
	
	device_unregister(mydrv_class_dev);
	class_destroy(mydrv_class);
}

module_init(mydrv_init);
module_exit(mydrv_exit);

MODULE_LICENSE("GPL"); 
MODULE_DESCRIPTION("My Android Device"); 
