#include <linux/init.h> 
#include <linux/module.h> 
#include <linux/types.h> 
#include <linux/fs.h> 
#include <linux/proc_fs.h> 
#include <linux/device.h> 
#include <asm/uaccess.h> 
#include <linux/input.h> 
#include <linux/platform_device.h> 
#include <linux/miscdevice.h> 
#include <asm/uaccess.h>

struct myinput_keypad
{
    srtuct input_dev *input;
};

static struct myinput_keypad myinput_key = {0};

static void myinput_ioctrl()
{
    //down
    input_report_key(myinput_key.input, KEY_BACK, 1);
    input_sync(myinput_key.input);

    //up
    input_report_key(myinput_key.input, KEY_BACK, 0);
    input_sync(myinput_key.input);
}

static const struct file_operations myinput_fops = 
{
    .owner = THIS_MODULE,
    .unlocked_ioctrl = myinput_ioctrl;
};
    
static struct miscdevice myinput_dev =
{
    MISC_DYNAMIC_MINOR,
    "myinput",
    &myinput_fops,
};

static int __devinit myinput_probe(struct platform_device *pdev)
{
    struct input_dev *input_dev;
    int err = 0;

    pr_info("myinput probe\n");
    memset(&myinput_key, 0, sizeof(struct myinput_keypad));
    platform_set_drvdata(pdev, &myinput_key);

    input_dev = input_allocate_device();
    if(!input_dev)
    {
        pr_info("filed to allocate input device. \n");
        err = -EBUSY;
        goto err_free_mem;
    }

    input_dev->name = pdev->name;
    input_dev->dev.parent = &pdev->dev;

    input_set_capability(input_dev, EV_KEY, KEY_BACK);

    myinput_key.input = input_dev;
    input_set_drvdata(input_dev, &myinput_key);

    err = input_register_device(input_dev);
    if (err)
    {
        pr_info("can not input register device \n");
        goto err_free_dev;
    }

    device_init_wakeup(&pdev->dev, 1);

    pr_info("finish myinput probe! input:0x%x\n", input_dev);
    return 0;

err_free_mem:
    return 0;
err_free_dev:
    input_free_device(input_dev);

}

static int __devexit myinput_remove(struct platform_device *pdev)
{

}

static struct platform_driver myinput_driver = 
{
    .probe = myinput_probe,
    .remove = __devexit_p(myinput_remove),
    .driver = {
        .name = "ac83xx_myinput",
        .owner = THIS_MODULE,
    },

};

static int __init myinput_init(void)
{

    pr_info("myinput_init begin.\n");
    int ret = platform_driver_register(&myinput_driver);
    if (ret != 0)
    {
        pr_info("platform driver register filed!. \n");
    }

    ret = misc_register(&myinput_dev);
    if (ret)
    {
        pr_info("misc register filed ! \n");
    }

    return ret;
}

static void __exit myinput_exit(void)
{
    pr_info("myinput exit.\n"); 
    misc_deregister(&myinput_dev); 
    platform_driver_unregister(&myinput_driver); 
    return 0;
}

MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("My Input Device");

module_init(myinput_init);
module_exit(myinput_exit);
