#include <linux/init.h>
#include <linux/module.h>
#include <linux/types.h>
#include <linux/fs.h>
#include <linux/proc_fs.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include <linux/i2c-dev.h>

#include "myi2c.h"

//主设备号和从设备号
static int myi2c_major = 0;
static int myi2c_minor = 0;

//设备类别和设备变量
static struct class* myi2c_class = NULL;
static struct myi2c_android_dev* myi2c_dev = NULL;
struct i2c_client *myi2c_client = NULL;

//传统的设备文件操作方法
static int myi2c_open(struct inode* inode, struct file* flip); 
static int myi2c_release(struct inode* inode, struct file* flip); 
static int myi2c_ioctl( struct file *file, unsigned int cmd, unsigned long arg); 
static ssize_t myi2c_write(struct file *file, const char __user *buf,size_t count, loff_t *offset); 
static ssize_t myi2c_read (struct file *file, char __user *buf, size_t count,loff_t *offset);


//传统的设备文件操作方法 
static struct file_operations myi2c_fops = { 
    .owner = THIS_MODULE, 
    .open = myi2c_open, 
    .release = myi2c_release, 
    .unlocked_ioctl = myi2c_ioctl, 
    .read = myi2c_read, 
    .write = myi2c_write, 
};


//I2C operation 
static s32 myi2c_probe(struct i2c_client *client, const struct i2c_device_id *id);
static s32 myi2c_remove(struct i2c_client *client);


#define DEVICE_I2C_ADDRESS 0x10 ///0x11 //READ : 0x23 ; WRITE : 0x22 (0x11 << 1) 
#define DEVICE_I2C_NAME "mygpio_device"

//only one client
static const struct i2c_device_id myi2c_id[] = {
    {DEVICE_I2C_NAME, 0},
    {}
};

struct myi2c_platform_data
{
    uint32_t version;/* Use this entry for panels with */
    //reservation
    
};

static struct myi2c_platform_data platform_data = {

    .version = 10427,
};


static struct i2c_driver myi2c_driver = 
{
    .probe = myi2c_probe,
    .remove = myi2c_remove,
    .id_table = myi2c_id,
    .driver = {
        .name = DEVICE_I2C_NAME,
        .owner = THIS_MODULE,
    }

};


static s32 myi2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    pr_info("cuishang myi2c_probe\n");
    return 0;
}

static s32 myi2c_remove(struct i2c_client *client) 
{ 
    pr_info("cuishang myi2c_remove\n"); 
    return 0; 
}

static int AddToCharDev()
{
    int err = -1;
    dev_t dev = 0;
    struct device* temp = NULL;

    pr_info("cuishang Initializing myi2c device.\n");

    //分配设备号码
    err = alloc_chrdev_region(&dev, 0, 1, MYI2C_DEVICE_NODE_NAME);

    if(err < 0)
    {
        pr_info ("cuishang Failed to alloc char devce region.\n");
        goto fail;
    }

    // 分配设备结构体的空间 
    myi2c_dev = kmalloc( sizeof(struct myi2c_android_dev), GFP_KERNEL); 
    if(!myi2c_dev) 
    { 
        err = -ENOMEM; 
        pr_info("cuishang Failed to alloc myi2c_dev.\n"); 
        goto unregister; 
    } 
    //初始化设备 
    memset(myi2c_dev, 0, sizeof(struct myi2c_android_dev) ); 
    cdev_init( &(myi2c_dev->dev), &myi2c_fops);

    //注册字符设备
    myi2c_major = MAJOR(dev);
    myi2c_minor = MINOR(dev);
    dev_t devno = MKDEV(myi2c_major, myi2c_minor);

    ////myi2c_dev->dev.owner = THIS_MODULE; 
    myi2c_dev->dev.ops = &myi2c_fops; 
    err = cdev_add( &(myi2c_dev->dev), devno, 1);
    if (err)
    {
        pr_info("cuishangFailed to call cdev_add:%d.\n", err);
        goto cleanup;
    }

    //create device type directory myi2c on /sys/class/
    myi2c_class = class_create(THIS_MODULE, MYI2C_DEVICE_CLASS_NAME);
    if (IS_ERR(myi2c_class))
    {
        err = PTR_ERR(myi2c_class); 
        pr_info("cuishangFailed to create myi2c class.\n");
        goto destroy_cdev;
    }

    // create device file myi2c on /dev/ and /sys/class/myi2c 
    temp = device_create(myi2c_class, NULL, dev, "%s", MYI2C_DEVICE_FILE_NAME); 
    if(IS_ERR(temp)) 
    { 
        err = PTR_ERR(temp); 
        pr_info("cuishangFailed to create myi2c device.\n"); 
        goto destroy_class; 
    }

    pr_info("cuishangSuccessed to initialize myi2c device.\n"); 
    return 0;


destroy_class: 
    class_destroy(myi2c_class); 
destroy_cdev: 
    cdev_del(&myi2c_dev->dev); 
cleanup: 
    kfree(myi2c_dev); 
unregister: 
    unregister_chrdev_region(MKDEV(myi2c_major, myi2c_minor), 1); 
fail: 
    pr_info("cuishangcuishang failed to initialize myi2c device.\n"); 
    return err;
}

static int AddToI2CDev(){
    struct i2c_board_info info;
    struct i2c_adapter *adapter;
    struct i2c_client *client;

    memset(&info, 0, sizeof(struct i2c_board_info));

    info.addr = DEVICE_I2C_ADDRESS;
    info.platform_data = &platform_data;
    strlcpy(info.type, DEVICE_I2C_NAME, I2C_NAME_SIZE);

    adapter = i2c_get_adapter(0);
    if (!adapter)
    {
        pr_info("cuishangcan not get i2c adapter 0\n");
        return -ENODEV;
    }

    client = i2c_new_device(adapter, &info);
    if (!client)
    {
        pr_info("cuishangcan not add i2c device at 0x%x\n", (unsigned int)info.addr);
        return -ENODEV;
    }

    client->adapter = adapter;
    i2c_put_adapter(adapter);

    if(i2c_add_driver(&myi2c_driver) != 0) 
    { 
        pr_info("cuishangfailed to add i2c driver\n"); 
        return -ENODEV; 
    }

    myi2c_client = client; 
    myi2c_client->addr = DEVICE_I2C_ADDRESS; 
    pr_info("cuishang AddToI2CDev successed \n");
    return 0; 
}


static ssize_t myi2c_write(struct file *file, const char __user *buf,size_t count, loff_t *offset) 
{ 
    int ret = 0; 
    char *tmp = NULL; 

    tmp = kmalloc(count,GFP_KERNEL); 

    if(tmp == NULL) 
    { 
        pr_info("cuishang no memory for the writing!\n"); 
        ret = -ENOMEM; goto EXIT; 
    } 

    if(copy_from_user(tmp,buf,count) < 0) 
    { 
        ret = -EFAULT; 
        goto EXIT; 
    } 

    ret = i2c_master_send(myi2c_client,tmp,count); 

EXIT: kfree(tmp); 
    return ret; 
}

static ssize_t myi2c_read (struct file *file, char __user *buf, size_t count,loff_t *offset) 
{ 
    char *tmp = NULL; 
    int ret = 0; 

    tmp = kmalloc(count,GFP_KERNEL); 
    if(tmp == NULL) 
    { 
        pr_info("cuishang no memory for the reading!\n"); 
        return -ENOMEM; 
    } 

    ret = i2c_master_recv(myi2c_client,tmp,count); 
    if(ret >= 0) 
    { 
        ret = copy_to_user(buf,tmp,count) ? -EFAULT : ret; 
    }

    kfree(tmp); 
    return ret; 
}

//传统设备文件的打开接口 
static int myi2c_open(struct inode* inode, struct file* flip) 
{ 
    struct myi2c_android_dev* dev; 
    //将结构体变量保存到私有区域 
    dev = container_of(inode->i_cdev, struct myi2c_android_dev, dev); 
    flip->private_data = dev; 
    pr_info("cuishangmyi2c_open\n"); 
    return 0; 
}

//传统设备文件的释放接口 
static int myi2c_release(struct inode* inode, struct file* filp) 
{ 
    pr_info("cuishangmyi2c_release\n"); 
    return 0; 
}


static int myi2c_ioctl( struct file *file, unsigned int cmd, unsigned long arg) 
{ 
    pr_info("cuishangmyi2c_ioctl:%d\n",cmd); 
    switch (cmd) 
    { 
        case I2C_SLAVE: 
        case I2C_SLAVE_FORCE: 
        { 
            /* NOTE: devices set up to work with "new style" drivers 
            * can't use I2C_SLAVE, even when the device node is not 
            * bound to a driver. Only I2C_SLAVE_FORCE will work. 
            * 
            * Setting the PEC flag here won't affect kernel drivers, 
            * which will be using the i2c_client node registered with 
            * the driver model core. Likewise, when that client has 
            * the PEC flag already set, the i2c-dev driver won't see 
            * (or use) this setting. 
            */ 
            if ((arg > 0x3ff) ||(((myi2c_client->flags & I2C_M_TEN) == 0) && arg > 0x7f)) 
            { 
                return -EINVAL; 
            } 
            else 
            { 
                myi2c_client->addr = arg; 
                pr_info("myi2c_client->addr:%d\n",myi2c_client->addr); 
                break; 
            } 
        } 

        case I2C_RETRIES: 
        { 
            //设置重试次数 
            myi2c_client->adapter->retries = arg; 
            pr_info("myi2c_client->adapter->retries:%d\n",myi2c_client->adapter->retries); 
            break; 
        }

        case I2C_TIMEOUT: 
        { 
            /* For historical reasons, user-space sets the timeout 
            * value in units of 10 ms. 
            */ 
            //设置超时时间 
            myi2c_client->adapter->timeout = msecs_to_jiffies(arg * 10); 
            pr_info("myi2c_client->adapter->timeout:%d\n",myi2c_client->adapter->timeout);
            break; 
        } 
            
        default: 
        { 
            /* NOTE: returning a fault code here could cause trouble 
            * in buggy userspace code. Some old kernel bugs returned 
            * zero in this case, and userspace code might accidentally 
            * have depended on that bug. 
            */ 
            return -ENOTTY; 
        } 
    } 

    return 0; 
}



//模块初始化
static int __init myi2c_init(void) 
{ 
    pr_info("cuishangmyi2c_init begin.\n"); 
    int error = 0; 
    
    error = AddToCharDev(); 
    if(error != 0) 
    { 
        return error; 
    } 
    
    error = AddToI2CDev(); 
    if(error != 0) 
    { 
        return error; 
    } 
    
    pr_info("cuishangmyi2c_init end.\n"); 
    
    return 0; 
}



//卸载模块 
static void __exit myi2c_exit(void) 
{ 
    dev_t devno = MKDEV(myi2c_major, myi2c_minor); 
    pr_info("cuishangDestroy myi2c device.\n");
    //传统设备文件系统的接口设备 
    if(myi2c_dev) 
    { 
        cdev_del(&(myi2c_dev->dev) ); 
        kfree(myi2c_dev); 
    } 

    // destroy device number 
    unregister_chrdev_region(devno, 1); 
} 

MODULE_LICENSE("GPL"); 
MODULE_DESCRIPTION("First Android Device"); 

module_init(myi2c_init); 
module_exit(myi2c_exit);






